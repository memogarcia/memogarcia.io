<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="3.6.1">Jekyll</generator><link href="http://localhost:4000/feed.xml" rel="self" type="application/atom+xml" /><link href="http://localhost:4000/" rel="alternate" type="text/html" /><updated>2017-10-21T15:38:37+01:00</updated><id>http://localhost:4000/</id><title type="html">Memo Garcia</title><subtitle>This is my personal blog</subtitle><entry><title type="html">Pratai, event driven platform for OpenStack</title><link href="http://localhost:4000/faas/2017/10/21/pratai.html" rel="alternate" type="text/html" title="Pratai, event driven platform for OpenStack" /><published>2017-10-21T14:21:38+01:00</published><updated>2017-10-21T14:21:38+01:00</updated><id>http://localhost:4000/faas/2017/10/21/pratai</id><content type="html" xml:base="http://localhost:4000/faas/2017/10/21/pratai.html">&lt;p&gt;&lt;strong&gt;Note&lt;/strong&gt; This is a Work-In-Progress Document.&lt;/p&gt;

&lt;p&gt;Read the docs at &lt;a href=&quot;https://github.com/memogarcia/pratai-docs&quot;&gt;memogarcia/pratai-docs&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&quot;abstract&quot;&gt;Abstract&lt;/h3&gt;

&lt;p&gt;Pratai provides an incredibly flexible and resilient platform to migrate
workloads to the cloud that respond to events without having to manage any
server or network.&lt;/p&gt;

&lt;h3 id=&quot;how-it-works&quot;&gt;How it works&lt;/h3&gt;

&lt;p&gt;The goal of Pratai is simple. Deploy “code” (disclaimer, from now on I
will refer to code as functions), that will react to an event without
worrying about anything else, the platform handles the execution. Simple right?&lt;/p&gt;

&lt;p&gt;In order to achieve that, first, we need to deploy a function in a &lt;code class=&quot;highlighter-rouge&quot;&gt;zip&lt;/code&gt; format
for one of the languages that the platform supports,
the first one is python but more will be added in the future, after this a
docker image gets created with the custom
function and the requirements. e.g.&lt;/p&gt;

&lt;div class=&quot;language-python highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c&quot;&gt;# new_module.py&lt;/span&gt;
&lt;span class=&quot;kn&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;numpy&lt;/span&gt;  &lt;span class=&quot;c&quot;&gt;# yes you can install dependencies, just send a requirements.txt&lt;/span&gt;


&lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;local_function&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;payload&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;):&lt;/span&gt;
    &lt;span class=&quot;c&quot;&gt;# you can create local functions&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;payload&lt;/span&gt;


&lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;payload&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;bp&quot;&gt;None&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;):&lt;/span&gt;
    &lt;span class=&quot;c&quot;&gt;# a main function should always be declared&lt;/span&gt;
    &lt;span class=&quot;c&quot;&gt;# and using a payload as a parameter&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;local_function&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;payload&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;When a function gets created it will remain as inactive, waiting to be executed
whenever an event happens that the function is subscribed to, could be a webhook
endpoint, which can be assigned at creation time, or a message in a queue but
basically, every event will spawn a container that will execute the event and
then disappear.&lt;/p&gt;

&lt;h3 id=&quot;architecture&quot;&gt;Architecture&lt;/h3&gt;

&lt;p&gt;Pratai is conformed of 2 major pieces, the Control Plane and the Nodes.&lt;/p&gt;

&lt;h4 id=&quot;control-plane&quot;&gt;Control Plane&lt;/h4&gt;

&lt;p&gt;An API gateway, a database cluster and a load balancer, and agent and a scheduler
runs in the control plane.&lt;/p&gt;

&lt;p&gt;For the first version a API gateway built in python using flask will be made,
in the future I think Golang should be a better option for it.&lt;/p&gt;

&lt;p&gt;An elasticsearch cluster will power the storage of events, function metadata
and cluster information.&lt;/p&gt;

&lt;p&gt;And a nginx load balancer will connect 3 instances to the API in a &lt;code class=&quot;highlighter-rouge&quot;&gt;least_connect&lt;/code&gt;
manner.&lt;/p&gt;

&lt;h4 id=&quot;pratai-nodes&quot;&gt;Pratai Nodes&lt;/h4&gt;

&lt;p&gt;A Pratai node is composed by a driver and runtimes.&lt;/p&gt;

&lt;p&gt;When a new node is created it will automatically connect to the cluster and it
will start polling for events.&lt;/p&gt;

&lt;p&gt;A driver is basically a container orchestrator like swarm, kubernetes, plain
docker, etc. in this case we will use docker.&lt;/p&gt;

&lt;p&gt;The runtimes are the languages supported by the platform, they are a base
container image that contains an OS, a language and its dependencies, etc. that
can be used by the functions the users submits. e.g.&lt;/p&gt;

&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c&quot;&gt;# seed/Dockerfile&lt;/span&gt;
FROM ubuntu:14.04
RUN apt-get &lt;span class=&quot;nt&quot;&gt;-y&lt;/span&gt; update
RUN apt-get install &lt;span class=&quot;nt&quot;&gt;-y&lt;/span&gt; git unzip wget
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c&quot;&gt;# python27/Dockerfile&lt;/span&gt;

FROM pratai/seed:latest

RUN apt-get install &lt;span class=&quot;nt&quot;&gt;-y&lt;/span&gt; python python-dev python-setuptools python-pip
RUN pip install pip &lt;span class=&quot;nt&quot;&gt;--upgrade&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c&quot;&gt;# python27_template.txt&lt;/span&gt;
FROM pratai/python27:latest
RUN wget &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;zip_location&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
RUN unzip &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;zip_file&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
RUN pip install &lt;span class=&quot;nt&quot;&gt;-r&lt;/span&gt; requirements.txt
RUN mkdir /etc/pratai/
RUN mkdir /var/log/pratai/
RUN cp new_module.py /etc/pratai/
RUN git clone &lt;span class=&quot;s2&quot;&gt;&quot;repo_with_runtimes&quot;&lt;/span&gt;
CMD &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;python&quot;&lt;/span&gt;, &lt;span class=&quot;s2&quot;&gt;&quot;/pratai-runtimes/runtimes/python27/server.py&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;]&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h4 id=&quot;distributed-queues&quot;&gt;Distributed Queues&lt;/h4&gt;

&lt;p&gt;ZeroMQ is the choice for queuing and passing messages in pratai using the PUSH/PULL
architecture we can create a pipelines of messages that can be distributed
across multiple nodes.&lt;/p&gt;

&lt;p&gt;We will have a producer and a collector running in the scheduler, and consumers
running in the Pratai nodes, one consumer should be spawned per thread.&lt;/p&gt;

&lt;h3 id=&quot;events&quot;&gt;Events&lt;/h3&gt;

&lt;p&gt;A function can react to any event coming through webhooks or messages
in a queue, even events that happen in a database can trigger a function, is
important to notice that a response of a function is an event, so it can trigger
so chaining functions to build pipelines of data processing is easy with Pratai.&lt;/p&gt;

&lt;p&gt;There are 2 kinds of events, &lt;code class=&quot;highlighter-rouge&quot;&gt;async&lt;/code&gt; and &lt;code class=&quot;highlighter-rouge&quot;&gt;wait_for_response&lt;/code&gt;&lt;/p&gt;

&lt;h4 id=&quot;async&quot;&gt;Async&lt;/h4&gt;

&lt;p&gt;This is the default event for pratai, it will take a request or a message and
process it asynchronously, then, you can collect the logs or responses,
by default the response gets stored in a collector queue, that can send this
response as an input for other functions.&lt;/p&gt;

&lt;p&gt;You can use the async event in the following cases:&lt;/p&gt;

&lt;p&gt;1: Async + Webhook&lt;/p&gt;

&lt;p&gt;This is the default behaviour, in which a function will be executed
asynchronously when an HTTP POST requests hists its endpoint.&lt;/p&gt;

&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;pratai &lt;span class=&quot;k&quot;&gt;function&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;-create&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;name&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;--type&lt;/span&gt; async &lt;span class=&quot;nt&quot;&gt;--event&lt;/span&gt; webhook
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;2: Async + Message&lt;/p&gt;

&lt;p&gt;A function created with this configuration will executed asynchronously when a
message arrives in the event queues available for the platform.&lt;/p&gt;

&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;pratai &lt;span class=&quot;k&quot;&gt;function&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;-create&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;name&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;--type&lt;/span&gt; async &lt;span class=&quot;nt&quot;&gt;--event&lt;/span&gt; message &lt;span class=&quot;nt&quot;&gt;--subscribe_to&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;event_id&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;3: Async + Timer&lt;/p&gt;

&lt;p&gt;A function created with this configuration will executed asynchronously
every time a timer sends an event, the frequency of the events are set in minutes.&lt;/p&gt;

&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;pratai &lt;span class=&quot;k&quot;&gt;function&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;-create&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;name&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;-type&lt;/span&gt; async &lt;span class=&quot;nt&quot;&gt;--event&lt;/span&gt; timer &lt;span class=&quot;nt&quot;&gt;--frequency&lt;/span&gt; 5
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h4 id=&quot;wait-for-response&quot;&gt;Wait For Response&lt;/h4&gt;

&lt;p&gt;This is a request that works like a typical web server, you send a request and
you wait for a response and only works for webhooks events&lt;/p&gt;

&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;pratai &lt;span class=&quot;k&quot;&gt;function&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;-create&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;name&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;--type&lt;/span&gt; wait_for_response &lt;span class=&quot;nt&quot;&gt;--event&lt;/span&gt; webhook
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;components&quot;&gt;Components&lt;/h3&gt;

&lt;h4 id=&quot;api-gateway&quot;&gt;API Gateway&lt;/h4&gt;

&lt;p&gt;The API is the main interface for incoming webhook requests and for platform
configuration.&lt;/p&gt;

&lt;h4 id=&quot;agent&quot;&gt;Agent&lt;/h4&gt;

&lt;p&gt;The Agent is the main interface for events in queues and cron jobs.&lt;/p&gt;

&lt;h4 id=&quot;client&quot;&gt;client&lt;/h4&gt;

&lt;p&gt;python-prataiclient is the component that allows the user to interact with the
api from the command line interface, with it you can do stuff like this:&lt;/p&gt;

&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;pratai &lt;span class=&quot;k&quot;&gt;function&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;-create&lt;/span&gt; music_tag &lt;span class=&quot;nt&quot;&gt;--file&lt;/span&gt; /path/to/zip &lt;span class=&quot;nt&quot;&gt;--description&lt;/span&gt; &lt;span class=&quot;se&quot;&gt;\&lt;/span&gt;
    &lt;span class=&quot;s2&quot;&gt;&quot;extract metadata from music files&quot;&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;--memory&lt;/span&gt; 128

pratai &lt;span class=&quot;k&quot;&gt;function&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;-list&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Because this is OpenStack you should pass credentials to interact with the
platform&lt;/p&gt;

&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nb&quot;&gt;export &lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;OS_USERNAME&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;user
&lt;span class=&quot;nb&quot;&gt;export &lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;OS_PASSWORD&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;password
&lt;span class=&quot;nb&quot;&gt;export &lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;OS_TENANT_NAME&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;pratai_tenant
&lt;span class=&quot;nb&quot;&gt;export &lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;OS_PRATAI_URL&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;http://192.168.33.9:9096
&lt;span class=&quot;nb&quot;&gt;export &lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;OS_IDENTITY_API_VERSION&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;3
&lt;span class=&quot;nb&quot;&gt;export &lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;OS_AUTH_URL&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;http://192.168.33.9:5000/v3
&lt;span class=&quot;nb&quot;&gt;export &lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;OS_PROJECT_NAME&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;pratai_tenant
&lt;span class=&quot;nb&quot;&gt;export &lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;OS_PROJECT_DOMAIN_NAME&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;Default
&lt;span class=&quot;nb&quot;&gt;export &lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;OS_USER_DOMAIN_NAME&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;Default
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h4 id=&quot;drivers&quot;&gt;Drivers&lt;/h4&gt;

&lt;p&gt;A driver is a backend that orchestrate a container that contains the custom code.&lt;/p&gt;

&lt;h4 id=&quot;runtimes&quot;&gt;Runtimes&lt;/h4&gt;

&lt;p&gt;A runtime is a language that is supported by the platform, it contains the
language and its dependencies.&lt;/p&gt;

&lt;h4 id=&quot;scheduler&quot;&gt;Scheduler&lt;/h4&gt;

&lt;p&gt;The scheduler primarily consists of a set of Python daemons, though it requires
and integrates with a number of native system components for databases and
messaging capabilities.&lt;/p&gt;

&lt;p&gt;1; Scheduler&lt;/p&gt;

&lt;p&gt;The API and the Agent push messages to this queue which will be pre-processed
before being distributed among the pratai nodes.&lt;/p&gt;

&lt;p&gt;2; Collector&lt;/p&gt;

&lt;p&gt;When a function finish the function execution it will send the result and
status here in order to be stored in the database afterwards.&lt;/p&gt;

&lt;h3 id=&quot;security--secrets&quot;&gt;Security &amp;amp; Secrets&lt;/h3&gt;

&lt;p&gt;The functions that interact with external services most often that not they
require to use credentials to connect, for this, Barbican has been proposed to
help with this scenario.&lt;/p&gt;

&lt;p&gt;We definitely recommend using tokens instead of user/passwords when possible.&lt;/p&gt;

&lt;h3 id=&quot;community&quot;&gt;Community&lt;/h3&gt;

&lt;p&gt;Join us at &lt;code class=&quot;highlighter-rouge&quot;&gt;#pratai&lt;/code&gt; irc channel in &lt;code class=&quot;highlighter-rouge&quot;&gt;freenode&lt;/code&gt;&lt;/p&gt;

&lt;h3 id=&quot;repositories&quot;&gt;Repositories&lt;/h3&gt;

&lt;p&gt;&lt;a href=&quot;https://github.com/memogarcia/pratai-docs&quot;&gt;memogarcia/pratai-docs&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://github.com/memogarcia/pratai-agent&quot;&gt;memogarcia/pratai-agent&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://github.com/memogarcia/pratai-api&quot;&gt;memogarcia/pratai-api&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://github.com/memogarcia/pratai-scheduler&quot;&gt;memogarcia/pratai-scheduler&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://github.com/memogarcia/pratai-runtimes&quot;&gt;memogarcia/pratai-runtimes&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://github.com/memogarcia/pratai-drivers&quot;&gt;memogarcia/pratai-drivers&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&quot;references&quot;&gt;References&lt;/h3&gt;

&lt;p&gt;&lt;a href=&quot;http://www.reactivemanifesto.org&quot;&gt;The Reactive Manifesto&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://msdn.microsoft.com/en-us/library/dn600223.aspx&quot;&gt;Cloud Design Patterns&lt;/a&gt;&lt;/p&gt;</content><author><name></name></author><summary type="html">Note This is a Work-In-Progress Document.</summary></entry></feed>